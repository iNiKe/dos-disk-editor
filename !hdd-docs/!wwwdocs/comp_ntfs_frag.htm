<html>

<head>
<!-- Meta http equivalent was here                                     -->
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>DM - Фрагментация NTFS</title>
<link rel="stylesheet" type="text/css" href="default.css">
</head>

<body topmargin="0" leftmargin="0" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td bgcolor="#D8D8D8" width="1%">&nbsp;</td>
<td width="1%" bgcolor="#D8D8D8">&nbsp;</td>
<td nowrap bgcolor="#D8D8D8" valign="top" align="center">
<p align="center"><b>Фрагментация NTFS</b></p>
</td>

<td width="50%" bgcolor="#D8D8D8">
<hr width="90%">
</td>
<td width="1%" bgcolor="#D8D8D8">&nbsp;</td>
</tr>
<tr>
<td width="1%" bgcolor="#D8D8D8">&nbsp;</td>
<td width="2%"></td>
<td valign="top" colspan="2" width="85%" class="ms10j">
<p>&nbsp;
<p align="center"><b>Или факты, которые Diskeeper 'забывает'
нам рассказать...</b></p>
<p>&nbsp;&nbsp;В самом начале утверждалось, что NTFS
не подвержена фрагментации файлов. Это
оказалось не совсем так, и утверждение
сменили - NTFS препятствует фрагментации.
Оказалось, что и это не совсем так. То есть
она, конечно, препятствует, но толк от этого
близок к нулю... Сейчас уже понятно, что NTFS -
система, которая как никакая другая <b>предрасположена</b>
к фрагментации, что бы не утверждалось
официально. Единственное что - логически
она не очень от этого страдает. Все
внутренние структуры построены таким
образом, что фрагментация не мешает быстро
находить фрагменты данных. Но от
физического последствия фрагментации -
лишних движений головок - она, конечно, не
спасает. И поэтому - вперед и с песней...</p>
<hr width="90%" noshade color="#D8D8D8" align="center">
<p>&nbsp;&nbsp; NTFS - очень экономная система.
Размер кластеров в ней разумно минимален -
обычно это 4 кб (на стандартных сейчас
дисках в десяток-другой гигабайт). Как
известно, система сильнее всего
фрагментирует файлы когда свободное место
кончается, когда приходится использовать
мелкие дырки, оставшиеся от других файлов.
Тут возникает первое свойство NTFS, которое
прямо способствует серьезной фрагментации.<br>
&nbsp;&nbsp; Диск NTFS поделен на две зоны. В начала
диска идет MFT зона - зона, куда растет MFT, Master
File Table. Зона занимает минимум 12% диска, и
запись данных в эту зону невозможна. Это
сделано для того, чтобы не фрагментировался
хотя бы MFT. Но когда весь остальной диск
заполняется - зона сокращается ровно в два
раза :). И так далее. Таким образом мы имеем
не один заход окончания диска, а несколько.
В результате если NTFS работает при диске,
заполненном на около 90% - фрагментация
растет как бешенная.</p>
<ul>
<li>Попутное следствие - диск, заполненный
более чем на 88%, дефрагментировать почти
невозможно - даже API дефрагментации не может
перемещать данные в MFT зону. Может оказаться
так, что у нас не будет свободного места для
маневра.</li>
</ul>
<p>&nbsp;&nbsp; Далее. NTFS работает себе и работает,
и всё таки фрагментируется. Этому
способствует странный алгоритм нахождения
свободного места - второе серьезное
упущение. Если файл пишется большими
кусками - всё нормально. Но если файл
медленно растет - алгоритм такой: берется
какой-то определенный объем диска и
заполняется файлом до упора. Причем по
очень интересному алгоритму: сначала
заполняются большие дырки, потом маленькие.
Т.е. типичное распределение фрагментов
файла по размеру на фрагментированной NTFS
выглядит так (размеры фрагментов):<br>
&nbsp;&nbsp; 16 - 16 - 16 - 16 - 16 - [скачек назад] - 15 - 15 - 15 -
[назад] - 14 - 14 - 14 .... 1 - 1 - 1 -1 - 1...<br>
&nbsp;&nbsp; Так процесс идет до самых мелких
дырок в 1 кластер, несмотря на то, что на
диске наверняка есть и гораздо более
большие куски свободного места.</p>
<p>&nbsp;&nbsp; Может быть я забыл написать что-то
еще... Смысл в том, что никак нельзя сказать,
что NTFS препятствует фрагментации файлов.
Наоборот, она с радостью их фрагментирует.
Фрагментация NTFS через пол года работы
доведет до искреннего удивления любого
человека, знакомого с работой файловой
системой. Поэтому приходится запускать
дефрагментатор. Но на этом все наши
проблемы не заканчиваются, а, увы, <b>только
начинаются...</b></p>
<hr width="90%" noshade color="#D8D8D8" align="center">
<p>&nbsp;&nbsp; В NT существует стандартное API
дефрагментации. Обладающее интересным
ограничением для перемещения блоков файлов:
за один раз можно перемещать не менее 16
кластеров (!), причем начинаться эти
кластеры должны с позиции, кратной 16
кластерам в файле. В общем, операция
осуществляется исключительно по 16
кластеров. Следствия:</p>
<ul>
<li>В дырку свободного места менее 16
кластеров <b>нельзя ничего переместить</b> (кроме
сжатых файлов, но это тонкости).</li>
<li>Файл, будучи перемещенный в друге место,
оставляет после себя (на новом месте) &quot;временно
занятое место&quot;, дополняющее его по
размеру до кратности 16 кластерам.</li>
<li>При попытке как-то неправильно (&quot;не
кратно 16&quot;) переместить файл результат
часто непредсказуем. Что-то округляется,
что-то просто не перемещается.. Тем не менее,
всё место действия щедро рассыпается &quot;временно
занятым местом&quot;. Наверное о нас заботятся,
чтобы мы отстали от этого места - чтобы
алгоритм дефрагментации не клинило. :)</li>
<li>&quot;Временно занятое место&quot;
освобождается через некоторое время,
обычно где-то пол минуты. Гы.</li>
</ul>
<p>&nbsp;&nbsp; Тем не менее, логично было бы
использовать это API. Его и используют.
Поэтому процесс стандартной
дефрагментации, с поправками на
ограниченность API, идет следующими фазами,
не обязательно в этом порядке:</p>
<ul>
<li>Вынимание файлов из MFT зоны. Не специально
- просто обратно туда их положить не
представляется возможным :) Безобидная фаза,
и даже в чем то полезная.</li>
<li>Дефрагментация файлов. Безусловно
полезный процесс, несколько правда
осложняемый ограничениями кратности
перемещений - файлы часто приходится
перекладывать сильнее, чем это было бы
логично сделать по уму.</li>
<li>Дефрагментация MFT, виртуалки (pagefile.sys) и
каталогов. Возможна через API только в Windows2000,
иначе - при перезагрузке, отдельным
процессом, как в Diskeeper-е.</li>
<li>Складывание файлов ближе к началу - так
называемая дефрагментация свободного
места. Вот это - воистину страшный процесс...</li>
</ul>
<p>&nbsp;&nbsp; Допустим, мы хотим положить файлы
подряд в начало диска. Кладем один файл. Он
оставляет хвост занятости дополнения до
кратности 16. Кладем следующий - после хвоста,
естественно. Через некоторое время, по
освобождению хвоста, имеем дырку &lt;16
кластеров размером. Которую потом
невозможно заполнить через API
дефрагментации! В результате, до
оптимизации картина свободного места
выглядела так: много дырок примерно
одинакового размера. После оптимизации -
одна дыра в конце диска, и много маленьких
&lt;16 кластеров дырок в заполненном файлами
участке. Какие места в первую очередь
заполняются? Правильно, находящиеся ближе к
началу диска мелкие дырки &lt;16 кластеров...
Любой файл, плавно созданный на
прооптимизированном диске, будет состоять
из дикого числа фрагментов. Да, диск потом
можно оптимизировать снова. А потом еще раз..
и еще.. и так - желательно каждую неделю. Бред?
Реальность.</p>
<p>&nbsp;&nbsp; Таким образом, имеется два
примерно равнозначных варианта. Первый -
часто оптимизировать диск таким
дефрагментатором, смиряясь при этом с <b>дикой</b>
фрагментацией заново созданных файлов.
Второй вариант - вообще ничего не трогать, и
смириться с равномерной, но гораздо более
слабой фрагментацией всех файлов на диске.</p>
<div align="center">

<table border="0" width="100%" class="ms10j">
<tr>
<td width="10%" bgcolor="#D8D8D8">
<p align="center"><b><font size="7" face="Times New Roman">!</font></b></td>
<td>&nbsp;</td>
<td>&nbsp;&nbsp; Пока есть один дефрагментатор,
который игнорирует API дефрагментации и
работает как-то более напрямую - Norton Speeddisk 5.0
для NT. Когда его пытаются сравнить со всеми
остальными - Diskeeper, O&amp;O defrag, т.д. - не
упоминают этого главного, самого
принципиального, отличия. Просто потому,
что эта проблема тщательно скрывается, по
крайней мере уж точно не афишируется на
каждом шагу. Speeddisk - <b>единственная</b> на
сегодняшний день программа, которая может
оптимизировать диск полностью, не создавая
маленьких незаполненных фрагментов
свободного места. Стоит добавить также, что
  стандартное API не может дефрагментировать
  тома NTFS с кластером более 4 Кбайт - а SpeedDisk,
  по прежнему, может.</td>
</tr>
</table>

</div>
<p>&nbsp;&nbsp; К сожалению, в Windows 2000 засунули
дефрагментатор, который работает через API, и
соответственно плодит дырки &lt;16 кластеров.
Так что как только появится (если уже не
появился) - так сразу надо качать Speeddisk для
W2k. Как некоторый вывод из всего этого - все
остальные дефрагментаторы при одноразовом
применении просто <b>вредны</b>. Если вы
запускали его хоть раз - нужно запускать его
потом хотя бы раз в месяц, чтобы избавится
от фрагментации новоприбывающих файлов. В
этом основная суть сложности
дефрагментации NTFS теми средствами, которые
сложились исторически.</p>
<hr width="90%" noshade color="#D8D8D8" align="center">
<p>&nbsp;&nbsp; Хочется выразить огромную
благодарность человеку по имени Mark Russinovich&nbsp;
(<a href="http://www.sysinternals.com">http://www.sysinternals.com</a>),
который предоставил общественности .h и
примеры использования интерфейса
дефрагментации.</p>
<p>&nbsp;&nbsp; И напоследок - программа fv выводит
количество фрагментов в файлах текущего
каталога, а с ключом /v [имя файла] - список
размеров блоков(фрагментов) указанного
файла, в кластерах. Знак ~ означает, что
следующий фрагмент находился ближе к
началу диска, чем предыдущий. На все
остальные непонятные выводимые данные
советую внимания не обращать - что-то я туда
вписал, что-то было - в любом случае не очень
полезные данные :)<br>
Написал Андрей Шабалин (<a href="mailto:a.shabalin@public.mtu.ru">a.shabalin@public.mtu.ru</a>)<br>
</p>
<blockquote>
<table border="0" class="ms10">
<tr>
<td nowrap valign="middle"><a href="files/fv.rar"><b>fv.rar (12 кб)</b></a></td>
<td></td>
<td></td>
</tr>
<tr>
<td nowrap valign="middle"><b><a href="files/fv_source.rar">fv_source.rar (70
кб)</a></b></td>
<td></td>
<td>Исходные тексты (проект VC6)</td>
</tr>
</table>
</blockquote>
<p>&nbsp;&nbsp; Также была попытка написать
дефрагментатор :). Дело дошло до написания
мною программы, которая расчищает
указанный участок диска, разбрасывая файлы
куда попало. Она даже работает! Ну, в умелых
руках&nbsp; :). В общем, вам её не запустить даже
для этой цели, слишком всё коряво - ну да
разработчики меня поймут.. :) Тем не менее,
основа любого дефрагментатора уже написана.
Криво, правда, но дело поправимо. Кому
интересно - могу отдать и описать, как она
работает. В текущем виде какая либо
деятельность отключена, единственное что
она делает - кладет битовую карту
свободного места с указанного диска в файл
i4.dat. В принципе, если вы хотите посмотреть,
как распределяется свободное место на
вашем NTFS диске - тоже полезная программа :). Я
иногда её использую для этого.</p>
<blockquote>
<table border="0" class="ms10">
<tr>
<td nowrap valign="middle"><a href="files/defrag.rar"><b>defrag.rar (6 кб)</b></a></td>
<td></td>
<td></td>
</tr>
<tr>
<td nowrap valign="middle"><b><a href="files/defrag_source.rar">defrag_source.rar
(40 кб)</a></b></td>
<td></td>
<td>Исходные тексты (проект VC6)</td>
</tr>
</table>
</blockquote>
<p>&nbsp;
<hr width="90%" noshade color="#D8D8D8" align="center">
<ul>
  <li> <a href="comp_ntfs.htm"><b>Структура NTFS</b></a></li>
  <li> <a href="comp_ntfs_vs_fat.htm"><b> NTFS и FAT: скорость</b></a></li>
</ul>
<p><b>&nbsp;</b></td>

<td width="2%"></td>
</tr>
</table>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td background="images/h1.gif"><font size="2" face="Arial">&nbsp;<a href="index.htm">[на главную]</a></font></td>
<td background="images/h1.gif" valign="top">
<p align="right"><font size="2">24.02.2000&nbsp;</font></td>
</tr>
</table>

<br> </body>

</html>