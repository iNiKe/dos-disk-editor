<html>

<head>
<!-- Meta http equivalent was here                                     -->
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>DM - Журналирование NTFS</title>
<link rel="stylesheet" type="text/css" href="default.css">
</head>

<body topmargin="0" leftmargin="0" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td bgcolor="#D8D8D8" width="1%">&nbsp;</td>
<td width="1%" bgcolor="#D8D8D8">&nbsp;</td>
<td nowrap bgcolor="#D8D8D8" valign="top" align="center">
<p align="center"><b>Журналирование </b><b>NTFS</b></p>
</td>

<td width="50%" bgcolor="#D8D8D8">
<hr width="90%">
</td>
<td width="1%" bgcolor="#D8D8D8">&nbsp;</td>
</tr>
<tr>
<td width="1%" bgcolor="#D8D8D8">&nbsp;</td>
<td width="2%"></td>
<td valign="top" colspan="2" width="85%" class="ms10j">
<p>&nbsp;
<p>&nbsp;&nbsp; Данная 'статья' представляет собой отрывок из
моего материала ,
опубликованного на <a href="http://ixbt.stack.net/">iXBT</a>.
Тут в меру сил поясняется философия
журналирования NTFS. Для начала, видимо, надо
прочесть статью <a href="comp_ntfs.htm">Структура NTFS</a>
- если, конечно, вы уже этого не сделали.</p>
<hr>
<p><font face="Times New Roman" size="4"><span style="mso-fareast-font-family: Times New Roman; mso-ansi-language: RU; mso-fareast-language: RU; mso-bidi-language: AR-SA"><b>Журналирование
NTFS</b></span></font></p>
<p>Описание того простого факта, что NTFS
является журналируемой системой, повергло
многочисленных поклонников других
файловых и операционных систем в искреннее
возмущение. В многочисленных письмах,
адресованных мне, NTFS называли системой с
квази-журналированием или даже без
журналирования вообще, ставя в противовес
многочисленные файловые системы Unix. Мне
пришло также много писем, указывающих на
фатальные сбои NTFS, восстановится от которых
не удалось - данные были потеряны. В данной
части я попытаюсь, в меру своих сил и
понимания, объяснить философию
журналирования и средств защиты от сбоев
NTFS, а также пояснить причины появления
фатальных сбоев. Я постараюсь оправдать
подход корпорации Microsoft, которая сделала
всё именно так, как сделала - по крайней мере,
я изложу причины реализованных
технологических решений и те компромиссы,
на которые пришлось пойти коллективу
разработчиков NTFS.</p>
<p style="text-align:justify"><span style="color: black">&nbsp;<o:p>
</o:p>
</span></p>
<p style="text-align:justify"><b><span style="color: black">Журналируемые
операции<o:p>
</o:p>
</span></b></p>
<p style="text-align:justify"><span style="color: black">Прежде всего
хотелось бы рассказать о том, какие именно
операции журналируются. Совершенно
очевидно, что полный undo-файл, способный
откатить <b>абсолютно все</b> операции,
абсолютно невозможен как с точки зрения
быстродействия, так и с точки зрения
здравого смысла. Да, такое журналирование
дало бы возможность восстановить большее
число данных - например, при осуществлении
перезаписи трех мегабайт в середине файла
мы могли бы сначала сохранить новые данные
в логе, затем переписать туда же предыдущие
три мегабайта файла, и уж только затем
осуществлять операции с реальными данными.
Такой подход гарантировал бы полную
определенность с судьбой информации - мы
всегда смогли бы понять, какая часть данных
уже записалась на диск, а какая находится в
исходном, не обновленном состоянии. Такой
подход имеет всего один скромный
недостаток - небольшая накладочка по
быстродействию: для записи на диск трех
мегабайт мы вынуждены будем осуществить
разнообразные дисковые операции на объем в
три раза больший - девять мегабайт. Да, <b>полное</b>
журналирование также применяется - но в
основном в работе с базами данных. Если вы
желаете обеспечить полное журналирование
каких-либо данных, вы можете поставить MS SQL
или даже Oracle, который вообще не будет
пользоваться средствами какой либо
файловой системы и обеспечит сохранность
ваших данных в любых разумных условиях.
Сторонникам же полного журналирования
файловой системы я могу ответить одно:
сократить быстродействие операций записи в
три раза, на мой взгляд, является слишком
смелым решением для обязательного
применения - и на домашних компьютерах, и на
серверах.<o:p>
</o:p>
</span></p>
<p style="text-align:justify"><span style="color: black">Подход
разработчиков NTFS был принципиально иным.
Главный девиз был, видимо, не надежность
любой ценой, а неизменность быстродействия.
Журналирование просто <b>не должно</b> было
помешать работе файловой системы. Первый
логичный шаг - отменить полное
журналирование как абсолютно неприемлемое
с точки зрения быстродействия. В NTFS
применяется журналирование логических
структур, а не данных пользователя - отсюда
и идет фраза, что сохранность <b>данных</b> не
гарантируется, но тем не менее корректное
состояние самой системы будет
поддерживаться. То, что NTFS не журналирует
данные файлов, приводит на практике к
одному варианту потери данных - в том же
гипотетическом случае записи трех мегабайт,
в случае сбоя в процессе записи никогда уже
не удастся установить, какая часть данных
записалась, а какая осталась неизменна.
Операции, которые тем не менее
журналируются системой - это операции со
структурами самой системы, то есть с
файлами и каталогами: добавление файлов,
переименование, перенос, создание и
удаление (освобождение свободного места).
Журналируются также и операции
дефрагментации - то есть перемещения
фрагментов файлов. Одним словом, все <b>логические</b>
операции журналированы.<o:p>
</o:p>
</span></p>
<p style="text-align:justify"><span style="color: black">&nbsp;<o:p>
</o:p>
</span></p>
<p style="text-align:justify"><b><span style="color: black">Отложенная
запись и контрольные точки журналирования<o:p>
</o:p>
</span></b></p>
<p style="text-align:justify"><span style="color: black">Известно,
что любая современная система для
ускорения файловых операций вынуждена
использовать кэширование, в том числе -
кэширование операций записи. Так
называемая отложенная запись - принцип
кэширования, при котором данные,
предназначенные для записи на диск,
некоторое время сохраняются в кэше и лишь в
свободное от других занятий время
сохраняются физически. Отложенная запись
очень существенно повышает эффективность
дисковых операций, так как такое
кэширование группирует множество операций
в одну - это особенно эффективно, если
запись производится в компактные участки
диска. Еще один плюс отложенной записи - не
мешать более нужным операциям чтения, и
осуществлять запись только тогда, когда
система свободна и ей не требуется доступ к
диску для других нужд. Как согласовать
отложенную запись с журналированием? Это
довольно сложный вопрос, так как
откладывание записи делает возможным
потерю тех данных, которые находились в
очереди на физическую запись и не успели
записаться на диск до сбоя. Самое
неприятное здесь даже не потеря данных, а то,
что происходит рассогласование времени
записи: какие-то служебные области могут
быть обновлены, а какие-то смежные по смыслу
- еще нет, так как их обновление могло
отложится еще на пару секунд и не состоятся
из-за сбоя.<o:p>
</o:p>
</span></p>
<p style="text-align:justify"><span style="color: black">NTFS
справляется с этими проблемами с помощью
смысловой интеграции операций отложенной
записи и ведения журнала. При попытке
начать журналируемую операцию в лог тут же
записывается намерение - например, стереть
файл. Это случается без задержек - на этом
этапе отложенная запись не работает: это
плата за присутствие журналирования,
которой нельзя избежать. Но вот все
остальные операции уже идут в задержанном
режиме - то есть они могут состояться
частично (могут еще в придачу и не в том
порядке) или не состоятся вообще.
Единственная задержанная операция, работа
которой несколько отличается от простой
записи - запись в лог об удачном завершении
предыдущих транзакций, так называемая <b>контрольная
точка</b>. Через определенные промежутки
времени - обычно через каждые несколько
секунд - система в обязательном порядке
сбрасывает абсолютно все задержанные
операции на диск. После произведения этой
операции в журнал записывается простейшая
запись - контрольная точка - которая говорит
о том, что <b>все</b> предыдущие операции
выполнены корректно на всех уровнях - как на
логическом, так и на физическом. <o:p>
</o:p>
</span></p>
<p style="text-align:justify"><span style="color: black">Такой режим
работы - с помощью записей и контрольных
точек - с одной стороны, по прежнему
гарантирует полностью корректную работу
журналирования, а с другой стороны
практически <b>совершенно</b> не приводит к
замедлению работы: простановка контрольных
точек производится, считай, мгновенно, а
запись в журнал о начале операции
соответствует по трудозатратам записи
самих данных без отложенного кэширования.
Реальная же запись, осуществляемая позже, в
подавляющем числе случаев не мешает
никаким операциям и не идет в ущерб
производительности системы.<o:p>
</o:p>
</span></p>
<p style="text-align:justify"><span style="color: black">&nbsp;<o:p>
</o:p>
</span></p>
<p style="text-align:justify"><b><span style="color: black">Проблемы
отложенного журналирования: концепция
дублирования информации</span></b><span style="color: black"><o:p>
</o:p>
</span></p>
<p style="text-align:justify"><span style="color: black">Вся
вышеописанная теория достаточно хороша, но
способна тем не менее вызвать очень
неприятные последствия, если не учесть еще
нескольких вещей, о которых и пойдет речь.<o:p>
</o:p>
</span></p>
<p style="text-align:justify"><span style="color: black">Рассмотрим
такой случай: мы стираем файл. Журнал
получил запись - &quot;файл N стирается&quot;.
Затем запаздывающему кэшу стало угодно
осуществить сначала физическую пометку о
том, что место, занимаемое файлом,
освободилось, а уж только затем удалить
файл из физических структур MFT и каталога.
Допустим, диск находится в активной работе,
и на освободившееся место тут же
записывается другой файл.<span style="mso-spacerun: yes">&nbsp;
</span>В этот момент происходит сбой. Система,
загружаясь, исследует журнал и видит
незавершенную операцию &quot;файл N стирается&quot;
- вернее, как я уже описал выше, не
незавершенную, а просто операцию,
контрольная точка после которой
отсутствует, что автоматически говорит о её
незавершенности. Следующая фаза была бы &quot;откат
операции&quot; - то есть восстановление файла.
Одна незадача - место, физически занимаемое
файлом, содержит уже другие данные.<o:p>
</o:p>
</span></p>
<p style="text-align:justify"><span style="color: black">Для
недопущение таких ситуаций система,
желающая ограничиться логическим
журналированием, вынуждена применять
принцип &quot;временно занятого места&quot;.
Место, освобожденное каким-либо объектом
или записью о нем, не объявляется свободным
до тех пор, пока физически не завершились
все операции с логическими структурами.
Данный механизм в NTFS, по видимому, не
синхронизирован даже с проставлением
контрольных точек, так как типичное время
освобождения временно занятого места -
около 30 секунд, точки же идут чаще.<o:p>
</o:p>
</span></p>
<p style="text-align:justify"><span style="color: black">Данный
механизм применяется не только при
стирании файла, но и при самых разных
операциях: принцип журналирования - объект,
убранный или перемещенный на новое место,
должен иметь возможность корректно
откатить своё &quot;отбытие&quot; - то есть
данные, на которые ссылаются логические
структуры удаляемого или перемещаемого
объекта, необходимо еще на некоторое время
зарезервировать как занятое место (диска/каталога).
Это еще один шаг NTFS к полному
журналированию, где специфическим журналом
файловой информации служат сами данные
освобождаемых областей, не уничтожаемые
физически.<o:p>
</o:p>
</span></p>
<p style="text-align:justify"><span style="color: black">&nbsp;<o:p>
</o:p>
</span></p>
<p style="text-align:justify"><b><span style="color: black">Допущения,
обеспечивающие надежность<o:p>
</o:p>
</span></b></p>
<p style="text-align:justify"><span style="color: black">Ну хорошо,
скажете вы, всё так замечательно - но почему
же тогда разделы NTFS всё же летят?.. Сейчас я
постараюсь объяснить принципы, которые
приводит к тому, что вышеописанная модель
сможет обеспечить полную
восстанавливаемость логических структур.<o:p>
</o:p>
</span></p>
<p style="margin-left:18.0pt;text-align:justify;text-indent:
-18.0pt;mso-list:l0 level1 lfo1"><span style="color: black">·<span style="font-style: normal; font-variant: normal; font-weight: normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Жесткий диск, в штатном режиме, должен
записать именно то и именно туда, что и куда
ему сказано было записать операционной
системой. Данный принцип нарушается в
случае, если система имеет ненадежный шлейф,
процессор, память или контроллер - и это <b>самая
распространенная причина сбоев NTFS</b>. Вам
поможет: не разогнанный процессор, <b>дорогая
(качественная) </b>память, хорошая
материнская плата и протокол UDMA,
обеспечивающий контроль и восстановление
ошибок на участке контроллер-диск.<o:p>
</o:p>
</span></p>
<p style="margin-left:18.0pt;text-align:justify;text-indent:
-18.0pt;mso-list:l0 level1 lfo1"><span style="color: black">·<span style="font-style: normal; font-variant: normal; font-weight: normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Жесткий диск, в случае аварии,
отключения питания или получения от
контроллера сигнала &quot;сброс&quot; (в случае
внезапной перезагрузки материнской платы) <b>обязан</b>
корректно завершить запись данных текущего
физического сектора, если таковая
производилась на момент аварии.
Промежуточное состояние сектора <b>не
допускается</b>. Вам помогут современные
винчестеры, которые могут осуществить
данную операцию даже в случае полного
пропадания питания - у них хватит
буферизированной в конденсаторах энергии,
и их логика рассчитана на корректное
поведение в случае отказа питания при
записи.<o:p>
</o:p>
</span></p>
<p style="margin-left:18.0pt;text-align:justify;text-indent:
-18.0pt;mso-list:l0 level1 lfo1"><span style="color: black">·<span style="font-style: normal; font-variant: normal; font-weight: normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Диск обязан мгновенно осуществить
запись данных, отправленных с флагом &quot;не
кэшировать&quot;. Дело в том, что многие
современные диски или контроллеры
обеспечивают задержанную запись. Метафайлы
NTFS обновляются в режиме &quot;писать сразу&quot;,
и контроллер/диск обязан выполнять это
требование.<o:p>
</o:p>
</span></p>
<p style="margin-left:18.0pt;text-align:justify;text-indent:
-18.0pt;mso-list:l0 level1 lfo1"><span style="color: black">·<span style="font-style: normal; font-variant: normal; font-weight: normal">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</span>Жесткий диск <b>обязан </b>обеспечить
чтение именно тех данных, которые были
записаны. В случае невозможности прочесть
данные выдается сигнал &quot;ошибка&quot;. Диск <b>не
имеет права</b> возвращать ошибочные данные (возможно,
лишь частично некорректные) без сигнала об
ошибке. Все современные жесткие диски имеют
контрольные суммы секторов и жестко
следуют этой логике поведения.<o:p>
</o:p>
</span></p>
<p style="text-align:justify"><span style="color: black">&nbsp;<o:p>
</o:p>
</span></p>
<p style="text-align:justify"><span style="color: black">Четкое
выполнение этих требований <b>полностью </b>гарантирует
надежную работу NTFS. Структура файловой
системы не будет содержать существенных
ошибок даже после сбоя. Некоторые
несущественные ошибки всё же появляются из-за
того, что логика журналирование часто
пытается завершить недоделанные операции -
например, то же удаление файла - тогда как
полную надежность обеспечивал бы только
безусловный откат всего, что находится
после последней контрольной точки. Малые
несоответствия, рождающиеся из этих
попыток, относятся к избыточной информации
системы безопасности, не представляют <b>никакой</b>
реальной опасности для данных - они
действительно незначительны. Суть этих
несоответствий чаще всего заключается в
том, что на диске остаются &quot;лишние&quot;
данные о тех режимах доступа, которые уже
не понадобятся системе. Их прочистка - дело
сугубо повышения производительности, как,
например, дефрагментация, поэтому их
наличие не является на самом деле ошибкой. В
случае же обнаружения серьезных, реальных,
проблем драйвер сам установит флажок тома
&quot;грязный&quot;, что проинструктирует
систему проверить том при следующем его
монтировании.<o:p>
</span></p>
<p style="text-align:justify"><span style="color: black">Я с большим
сожалением должен сказать, что подавляющее
большинство фатальных ошибок NTFS происходит
по вине аппаратуры, не выполняющей эти
элементарные требования. Да, я понимаю,
абсолютной надежности не бывает. Но Microsoft
пошел по пути разделения труда - за
надежность вашей аппаратуры корпорация
ответственности не несет. Мой компьютер на
70% не попадает в список совместимого с Windows
2000 оборудования, и то же самое можно сказать
про почти любую реальную машину,
функционирующую на просторах бывшего СССР.
Особенно это относится к любителям
разгонять компьютеры. Запомните раз и
навсегда: вы с огромной степенью
вероятности угробите NTFS в первый же год
работы, если ваш процессор - 333, разогнанный
на 450. И даже не раз.. Мне очень жаль, но это
действительно так. От любых сбоев <b>корректного</b>
компьютера NTFS защитит, но вот от записи
случайных данных в бут-сектор (копия
которого, кстати, хранится в самом конце
раздела)<span style="mso-spacerun: yes">&nbsp; </span>и в MFT
система просто <b>не страхуется</b>. Извините.<br>
&nbsp;<o:p></o:p>
</span></p>
<hr width="90%" noshade color="#D8D8D8" align="center">
<ul>
  <li> <a href="comp_ntfs.htm"><b>Структура NTFS</b></a></li>
  <li> <a href="comp_ntfs_frag.htm"><b>Фрагментация NTFS</b></a></li>
  <li> <a href="comp_ntfs_vs_fat.htm"><b>NTFS и FAT: скорость</b></a></li>
</ul>
<p>&nbsp;</p>
</td>
<td width="2%"></td>
</tr>
</table>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td background="images/h1.gif">&nbsp;<font size="2" face="Arial"><a href="index.htm">[на главную]</a></font></td>
<td background="images/h1.gif" valign="top">
<p align="right"><font size="2">21.08.2000&nbsp;</font></td>
</tr>
</table>


<br> </body>

</html>